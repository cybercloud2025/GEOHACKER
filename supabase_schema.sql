-- ==============================================================================
-- ANTIGRAVITY TIME TRACKER - SUPABASE SCHEMA
-- ==============================================================================

-- 1. ENABLE EXTENSIONS
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto"; -- Required for PIN hashing if not using Edge Functions only

-- ==============================================================================
-- 2. TABLES
-- ==============================================================================

-- 2.1 EMPLOYEES
CREATE TABLE IF NOT EXISTS employees (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  pin_hash TEXT NOT NULL, 
  role TEXT NOT NULL DEFAULT 'employee' CHECK (role IN ('employee', 'admin')),
  is_active BOOLEAN DEFAULT true,
  avatar_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2.2 TIME_ENTRIES
CREATE TABLE IF NOT EXISTS time_entries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  employee_id UUID REFERENCES employees(id) ON DELETE CASCADE NOT NULL,
  start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  end_time TIMESTAMPTZ, -- NULL while active
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'break', 'completed')),
  start_location JSONB, -- {lat, lng, accuracy}
  end_location JSONB,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2.3 BREAKS
CREATE TABLE IF NOT EXISTS breaks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  time_entry_id UUID REFERENCES time_entries(id) ON DELETE CASCADE NOT NULL,
  start_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  end_time TIMESTAMPTZ,
  reason TEXT
);

-- 2.4 LOCATIONS
CREATE TABLE IF NOT EXISTS locations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  employee_id UUID REFERENCES employees(id) ON DELETE CASCADE NOT NULL,
  time_entry_id UUID REFERENCES time_entries(id) ON DELETE CASCADE NOT NULL,
  latitude DOUBLE PRECISION NOT NULL,
  longitude DOUBLE PRECISION NOT NULL,
  accuracy DOUBLE PRECISION,
  heading DOUBLE PRECISION,
  speed DOUBLE PRECISION,
  battery_level INTEGER,
  timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- ==============================================================================
-- 3. ROW LEVEL SECURITY (RLS)
-- ==============================================================================

-- Enable RLS on all tables
ALTER TABLE employees ENABLE ROW LEVEL SECURITY;
ALTER TABLE time_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE breaks ENABLE ROW LEVEL SECURITY;
ALTER TABLE locations ENABLE ROW LEVEL SECURITY;

-- 3.1 POLICIES (Drop first to avoid errors on re-run)
DROP POLICY IF EXISTS "Allow read access for valid sessions" ON employees;
CREATE POLICY "Allow read access for valid sessions" ON employees
FOR SELECT USING (true); -- Ideally restrict this more in production

DROP POLICY IF EXISTS "Employees can insert their own entries" ON time_entries;
CREATE POLICY "Employees can insert their own entries" ON time_entries
FOR INSERT WITH CHECK (employee_id = (current_setting('app.current_employee_id', true)::uuid));

DROP POLICY IF EXISTS "Employees can view own entries" ON time_entries;
CREATE POLICY "Employees can view own entries" ON time_entries
FOR SELECT USING (employee_id = (current_setting('app.current_employee_id', true)::uuid));

DROP POLICY IF EXISTS "Employees can update own active entries" ON time_entries;
CREATE POLICY "Employees can update own active entries" ON time_entries
FOR UPDATE USING (employee_id = (current_setting('app.current_employee_id', true)::uuid));

DROP POLICY IF EXISTS "Enable insert for active employees" ON locations;
CREATE POLICY "Enable insert for active employees" ON locations
FOR INSERT WITH CHECK (true);

-- ==============================================================================
-- 4. FUNCTIONS & PROCEDURES
-- ==============================================================================

-- 4.1 VERIFY PIN
-- Returns employee data + token (simulated) if PIN matches.
-- NOTE: In a real Supabase Auth setup, this might issue a JWT. 
-- For this simpler approach, we return the Employee ID to client to store in Session Storage 
-- (and Client secures it). 
-- WARNING: This uses pgcrypto `crypt` comparison.

CREATE OR REPLACE FUNCTION verify_employee_pin(p_employee_id UUID, p_pin TEXT)
RETURNS BOOLEAN AS $$
DECLARE
  stored_hash TEXT;
BEGIN
  SELECT pin_hash INTO stored_hash FROM employees WHERE id = p_employee_id;
  RETURN (stored_hash = crypt(p_pin, stored_hash));
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4.2 CLOCK IN (Rpc)
-- Simplify client interactions
CREATE OR REPLACE FUNCTION clock_in(p_employee_id UUID, p_location JSONB)
RETURNS UUID AS $$
DECLARE
  v_entry_id UUID;
BEGIN
  -- Check if already active
  IF EXISTS (SELECT 1 FROM time_entries WHERE employee_id = p_employee_id AND status IN ('active', 'break')) THEN
    RAISE EXCEPTION 'Employee already has an active shift';
  END IF;

  INSERT INTO time_entries (employee_id, start_time, status, start_location)
  VALUES (p_employee_id, NOW(), 'active', p_location)
  RETURNING id INTO v_entry_id;

  RETURN v_entry_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4.3 CLOCK OUT
CREATE OR REPLACE FUNCTION clock_out(p_employee_id UUID, p_location JSONB, p_notes TEXT DEFAULT NULL)
RETURNS BOOLEAN AS $$
DECLARE
  v_entry_id UUID;
BEGIN
  SELECT id INTO v_entry_id FROM time_entries 
  WHERE employee_id = p_employee_id AND status IN ('active', 'break') 
  ORDER BY start_time DESC LIMIT 1;

  IF v_entry_id IS NULL THEN
    RAISE EXCEPTION 'No active shift found';
  END IF;

  -- Close open breaks if any
  UPDATE breaks SET end_time = NOW() WHERE time_entry_id = v_entry_id AND end_time IS NULL;

  UPDATE time_entries 
  SET end_time = NOW(), status = 'completed', end_location = p_location, notes = p_notes
  WHERE id = v_entry_id;

  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ==============================================================================
-- 5. SEED DATA
-- ==============================================================================
-- Insert a test admin and employee
-- PIN for both is '1234' -> hash generated via pgcrypto: crypt('1234', gen_salt('bf'))
INSERT INTO employees (first_name, last_name, pin_hash, role)
VALUES 
('Admin', 'User', crypt('9270', gen_salt('bf')), 'admin'),
('John', 'Doe', crypt('1234', gen_salt('bf')), 'employee');

-- 4.4 LOGIN WITH PIN (New)
-- Finds an active employee with the matching PIN.
-- Returns Employee data if found.
CREATE OR REPLACE FUNCTION login_with_pin(p_pin TEXT)
RETURNS JSONB AS $$
DECLARE
  v_employee RECORD;
BEGIN
  -- Iterate through active employees to find match (Generic approach)
  -- Note: This might be slow if 10k employees, but fine for <100.
  FOR v_employee IN SELECT * FROM employees WHERE is_active = true LOOP
    IF v_employee.pin_hash = crypt(p_pin, v_employee.pin_hash) THEN
      RETURN jsonb_build_object(
        'id', v_employee.id,
        'first_name', v_employee.first_name,
        'last_name', v_employee.last_name,
        'role', v_employee.role
      );
    END IF;
  END LOOP;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
